# -*- coding: utf-8 -*-
"""CDIP SWH LA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1218GN0bYdA36vlkCwbC3UUkk5RDnCXsc
"""

import netCDF4

# Set the station code
stn = '045'

# Construct the URL for the netCDF file
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/archive/' + stn + 'p1/' + stn + 'p1_historic.nc'

# Read the data from the netCDF file
nc = netCDF4.Dataset(data_url)

# Print the available variables in the netCDF file
print(nc.variables.keys())

# Access a specific variable and print its data
waves = nc.variables['waveHs']
print(waves[:])

import netCDF4
import numpy as np

# Set the station code
stn = '045'

# Construct the URL for the netCDF file
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/archive/' + stn + 'p1/' + stn + 'p1_historic.nc'

# Read the data from the netCDF file
nc = netCDF4.Dataset(data_url)

# Extract the significant wave height (Hs) and peak wave period (Tp)
Hs = nc.variables['waveHs'][:]
Tp = nc.variables['waveTp'][:]

# Calculate the wavelength (L)
g = 9.81
L = g * Tp**2 / (2 * np.pi)

# Calculate the length-adjusted wave height (Hs_adj)
Hs_adj = Hs * (Tp / (g * L)**0.5)

# Print the length-adjusted wave height for the first 10 time steps
print(Hs_adj[:10])

import netCDF4
import numpy as np
import matplotlib.pyplot as plt

# Set the station code
stn = '045'

# Construct the URL for the netCDF file
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/archive/' + stn + 'p1/' + stn + 'p1_historic.nc'

# Read the data from the netCDF file
nc = netCDF4.Dataset(data_url)

# Extract the significant wave height (Hs) and peak wave period (Tp)
Hs = nc.variables['waveHs'][:]
Tp = nc.variables['waveTp'][:]

# Calculate the wavelength (L)
g = 9.81
L = g * Tp**2 / (2 * np.pi)

# Calculate the length-adjusted wave height (Hs_adj) in feet
Hs_adj = Hs * (Tp / (g * L)**0.5) * 3.28084

# Create a plot of the length-adjusted wave height
plt.plot(nc.variables['waveTime'][:], Hs_adj)
plt.xlabel('Time')
plt.ylabel('Length-Adjusted Wave Height (ft)')
plt.title('Length-Adjusted Wave Height for Station ' + stn)
plt.show()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# set the buoy station number
stn = '045'

# set the length of the wave period for length adjustment
T = 12

# set the date range
end_time = datetime.utcnow()
start_time = end_time - timedelta(days=1)

# CDIP Realtime Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + stn + 'p1_rt.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height and period variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]

# calculate length adjusted wave height
lah = hs_data / (T ** 0.5)

# convert from meters to feet
lah = lah * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects
time_array = [datetime.fromisoformat(str(t)) for t in time_array]

# create the plot
plt.plot(time_array, lah)

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + stn)
plt.xlabel('Time')
plt.ylabel('Wave Height (ft)')
plt.grid()

# display the plot
plt.show()

# close the NetCDF dataset
nc.close()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# set the buoy station number
stn = '045'

# set the length of the wave period for length adjustment
T = 12

# set the date range
end_time = datetime.utcnow()
start_time = end_time - timedelta(hours=12)

# CDIP Realtime Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + stn + 'p1_rt.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height and period variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]

# calculate length adjusted wave height
lah = hs_data / (T ** 0.5)

# convert from meters to feet
lah = lah * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects
time_array = [datetime.fromisoformat(str(t)) for t in time_array]

# resample the data to every 30 minutes
new_time_array = []
new_lah = []
for i in range(len(time_array)):
    if i == 0:
        new_time_array.append(time_array[i])
        new_lah.append(lah[i])
    else:
        diff = time_array[i] - new_time_array[-1]
        if diff.seconds >= 1800:
            new_time_array.append(time_array[i])
            new_lah.append(lah[i])

# create the plot
plt.plot(new_time_array, new_lah)

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + stn)
plt.xlabel('Time')
plt.ylabel('Wave Height (ft)')
plt.grid()

# display the plot
plt.show()

# close the NetCDF dataset
nc.close()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# set the buoy station number
stn = '045'

# set the length of the wave period for length adjustment
T = 12

# set the date range
end_time = datetime.utcnow()
start_time = end_time - timedelta(hours=12)

# CDIP Realtime Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + stn + 'p1_rt.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height and period variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]

# calculate length adjusted wave height
lah = hs_data / (T ** 0.5)

# convert from meters to feet
lah = lah * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects
time_array = [datetime.fromisoformat(str(t)) for t in time_array]

# resample the data to every 30 minutes
new_time_array = []
new_lah = []
for i in range(len(time_array)):
    if i == 0:
        new_time_array.append(time_array[i])
        new_lah.append(lah[i])
    else:
        diff = time_array[i] - new_time_array[-1]
        if diff.seconds >= 1800:
            new_time_array.append(time_array[i])
            new_lah.append(lah[i])

# create the plot
fig, ax = plt.subplots()
ax.plot(new_time_array, new_lah)

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + stn)
plt.xlabel('Date and Time')
plt.ylabel('Wave Height (ft)')
plt.grid()

# set the x-axis format to show date and time in hh:mm format
date_format = '%m/%d/%Y %H:%M'
date_formatter = plt.matplotlib.dates.DateFormatter(date_format)
ax.xaxis.set_major_formatter(date_formatter)
fig.autofmt_xdate()

# display the plot
plt.show()

# close the NetCDF dataset
nc.close()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz

# set the buoy station number
#stn = '045'
stn = '264'

# set the length of the wave period for length adjustment
T = 12

# set the date range
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(hours=12)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Realtime Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + stn + 'p1_rt.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height and period variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]

# calculate length adjusted wave height
lah = hs_data / (T ** 0.5)

# convert from meters to feet
lah = lah * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects
time_array = [datetime.fromisoformat(str(t)) for t in time_array]

# resample the data to every 30 minutes
new_time_array = []
new_lah = []
for i in range(len(time_array)):
    if i == 0:
        new_time_array.append(time_array[i])
        new_lah.append(lah[i])
    else:
        diff = time_array[i] - new_time_array[-1]
        if diff.seconds >= 1800:
            new_time_array.append(time_array[i])
            new_lah.append(lah[i])

# convert the datetime objects to UTC time zone
new_time_array_utc = [t.astimezone(utc_tz) for t in new_time_array]

# convert the datetime objects to PST time zone
new_time_array_pst = [t.astimezone(pst_tz) for t in new_time_array_utc]

# adjust the time offset by 6 hours
new_time_array_pst = [t - timedelta(hours=6) for t in new_time_array_pst]

# create the plot
fig, ax = plt.subplots()
ax.plot(new_time_array_pst, new_lah)

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + stn)
plt.xlabel('Time (PST)')
plt.ylabel('Wave Height (ft)')
plt.grid()

# set the x-axis format to show date and time in hh:mm format
date_format = '%m/%d/%Y %H:%M'
date_formatter = plt.matplotlib.dates.DateFormatter(date_format)
ax.xaxis.set_major_formatter(date_formatter)
fig.autofmt_xdate()

# display the plot
plt.show()

# close the NetCDF dataset
nc.close()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz
from sklearn.linear_model import LinearRegression

# set the buoy station number
buoy_number = '045'

# set the length of the wave period for length adjustment
T = 12

# set the date range for historic data
end_time_utc_h = datetime.utcnow() - timedelta(days=1)
start_time_utc_h = end_time_utc_h - timedelta(days=7)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time_h = utc_tz.localize(end_time_utc_h).astimezone(pst_tz)
start_time_h = utc_tz.localize(start_time_utc_h).astimezone(pst_tz)

# CDIP Historic Dataset URL
data_url_h = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/archive/' + buoy_number +'p1/' + buoy_number + 'p1_historic.nc'

# open the NetCDF dataset for historic data
nc_h = netCDF4.Dataset(data_url_h)

# get the time variable for historic data
time_var_h = nc_h.variables['waveTime']

# find the indices for the historic time range
start_index_h = netCDF4.date2index(start_time_h, time_var_h, select='nearest')
end_index_h = netCDF4.date2index(end_time_h, time_var_h, select='nearest')

# get the wave height and period variables for historic data
hs_var_h = nc_h.variables['waveHs']
t_var_h = nc_h.variables['waveTp']

# extract the wave height and period data for the historic time range
hs_data_h = hs_var_h[start_index_h:end_index_h+1]
t_data_h = t_var_h[start_index_h:end_index_h+1]

# calculate length adjusted wave height for historic data
lah_h = hs_data_h / (T ** 0.5)

# convert from meters to feet
lah_h = lah_h * 3.281

# create a time array for training
time_array_h = netCDF4.num2date(time_var_h[start_index_h:end_index_h+1], time_var_h.units).tolist()

# convert the cftime objects to datetime objects
time_array_h = [datetime.fromisoformat(str(t)) for t in time_array_h]

# create a feature matrix for linear regression
X_h = np.array(time_array_h).reshape((-1, 1))
y_h = np.array(lah_h)

# create a linear regression object
model = LinearRegression()

# fit the model with the training data
model.fit(X_h, y_h)

# close the NetCDF dataset for historic data
nc_h.close()

# set the date range for real-time data
end_time_utc_r = datetime.utcnow()
start_time_utc_r = end_time_utc_r - timedelta(hours=12)

# convert UTC time to PST time
end_time_r = utc_tz.localize(end_time_utc_r).astimezone(pst_tz)
start_time_r = utc_tz.localize(start_time_utc_r).astimezone(pst_tz)

# CDIP Realtime Dataset URL
data_url_r = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + buoy_number + 'p1_rt.nc'

# open the NetCDF dataset for real-time data
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height and period variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]

# calculate length adjusted wave height
lah = hs_data / (T ** 0.5)

# convert from meters to feet
lah = lah * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects
time_array = [datetime.fromisoformat(str(t)) for t in time_array]

# resample the data to every 30 minutes
new_time_array = []
new_lah = []
for i in range(len(time_array)):
    if i == 0:
        new_time_array.append(time_array[i])
        new_lah.append(lah[i])
    else:
        diff = time_array[i] - new_time_array[-1]
        if diff.seconds >= 1800:
            new_time_array.append(time_array[i])
            new_lah.append(lah[i])

# convert the datetime objects to UTC time zone
new_time_array_utc = [t.astimezone(utc_tz) for t in new_time_array]

# convert the datetime objects to PST time zone
new_time_array_pst = [t.astimezone(pst_tz) for t in new_time_array_utc]

# adjust the time offset by 6 hours
new_time_array_pst = [t - timedelta(hours=6) for t in new_time_array_pst]

# create the plot
fig, ax = plt.subplots()
ax.plot(new_time_array_pst, new_lah)

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + stn)
plt.xlabel('Time (PST)')
plt.ylabel('Wave Height (ft)')
plt.grid()

# set the x-axis format to show date and time in hh:mm format
date_format = '%m/%d/%Y %H:%M'
date_formatter = plt.matplotlib.dates.DateFormatter(date_format)
ax.xaxis.set_major_formatter(date_formatter)
fig.autofmt_xdate()

# display the plot
plt.show()

# close the NetCDF dataset
nc.close()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz
from sklearn.linear_model import LinearRegression

# set the buoy station number
buoy_number = '045'

# set the length of the wave period for length adjustment
T = 12

# set the date range
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(days=7)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Historic Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/archive/' + buoy_number +'p1/' + buoy_number + 'p1_historic.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height and period variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]

# calculate length adjusted wave height
lah = hs_data / (T ** 0.5)

# convert from meters to feet
lah = lah * 3.281

# create a time array for training
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects
time_array = [datetime.fromisoformat(str(t)) for t in time_array]

# convert datetime objects to Unix timestamps
timestamps = [(t - datetime(1970, 1, 1, tzinfo=pytz.utc)).total_seconds() for t in time_array]

# create a feature matrix for linear regression
X = np.array(timestamps).reshape((-1, 1))
y = np.array(lah)

# create a linear regression object
model = LinearRegression()

# fit the model with the training data
model.fit(X, y)

# close the NetCDF dataset
nc.close()

# set the date range for real-time data
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(hours=12)

# convert UTC time to PST time
end_time = utc_tz.localize(end_time_utc).ast

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz
from sklearn.linear_model import LinearRegression

# set the buoy station number
buoy_number = '045'

# set the length of the wave period for length adjustment
T = 12

# set the date range
end_time_utc = datetime.utcnow().replace(tzinfo=pytz.utc)
start_time_utc = end_time_utc - timedelta(days=7)

# convert UTC time to PST time
pst_tz = pytz.timezone('US/Pacific')
end_time = end_time_utc.astimezone(pst_tz)
start_time = start_time_utc.astimezone(pst_tz)

# CDIP Historic Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/archive/' + buoy_number +'p1/' + buoy_number + 'p1_historic.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height and period variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]

# calculate length adjusted wave height
lah = hs_data / (T ** 0.5)

# convert from meters to feet
lah = lah * 3.281

# create a time array for training
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects with timezone information
time_array = [pytz.utc.localize(t).astimezone(pst_tz) for t in time_array]

# create a feature matrix for linear regression
X = np.array(time_array).reshape((-1, 1))
y = np.array(lah)

# create a linear regression object
model = LinearRegression()

# fit the model with the training data
model.fit(X, y)

# close the NetCDF dataset
nc.close()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz
from sklearn.linear_model import LinearRegression

# set the buoy station number
buoy_number = '045'

# set the length of the wave period for length adjustment
T = 12

# set the date range
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(days=7)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = pst_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = pst_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Historic Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/archive/' + buoy_number +'p1/' + buoy_number + 'p1_historic.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time.replace(tzinfo=None), time_var, select='nearest')
end_index = netCDF4.date2index(end_time.replace(tzinfo=None), time_var, select='nearest')

# get the wave height and period variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]

# calculate length adjusted wave height
lah = hs_data / (T ** 0.5)

# convert from meters to feet
lah = lah * 3.281

# create a time array for training
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects
time_array = [pst_tz.localize(datetime.fromisoformat(str(t))) for t in time_array]

# create a feature matrix for linear regression
X = np.array(time_array).reshape((-1, 1))
y = np.array(lah)

# create a linear regression object
model = LinearRegression()

# fit the model with the training data
model.fit(X, y)

# close the NetCDF dataset
nc.close()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz
from sklearn.linear_model import LinearRegression

# set the buoy station number
buoy_number = '045'

# set the length of the wave period for length adjustment
T = 12

# set the date range
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(days=7)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Historic Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/archive/' + buoy_number +'p1/' + buoy_number + 'p1_historic.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height and period variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]

# calculate length adjusted wave height
lah = hs_data / (T ** 0.5)

# convert from meters to feet
lah = lah * 3.281

# create a time array for plotting
time_array = []
for i in range(start_index, end_index+1):
    t = nc.variables['waveTime'][i]
    dt = netCDF4.num2date(t, time_var.units, time_var.calendar)
    dt = pytz.utc.localize(dt).astimezone(pst_tz)  # convert to PST timezone
    time_array.append(dt)

# create a feature matrix for linear regression
X = np.array([dt.timestamp() for dt in time_array]).reshape((-1, 1))
y = np.array(lah)

# create a linear regression object
model = LinearRegression()

# fit the model with the training data
model.fit(X, y)

# close the NetCDF dataset
nc.close()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz

# set the buoy station number
buoy_number = '045'

# set the length of the wave period for length adjustment
T = 12

# set the date range
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(days=7)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Historic Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/archive/' + buoy_number +'p1/' + buoy_number + 'p1_historic.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height and period variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]

# calculate length adjusted wave height
lah = hs_data / (T ** 0.5)

# convert from meters to feet
lah = lah * 3.281

# create a time array for training
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects and PST timezone
time_array = [datetime.fromisoformat(str(t)).astimezone(pst_tz) for t in time_array]

# create a feature matrix for linear regression
X = np.array([t.timestamp() for t in time_array]).reshape((-1, 1))
y = np.array(lah)

# create a linear regression object
model = LinearRegression()

# fit the model with the training data
model.fit(X, y)

# close the NetCDF dataset
nc.close()

# set the date range for real-time data
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(hours=12)

# convert UTC time to PST time
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Realtime Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + buoy_number + 'p1_rt.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height and period variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]

# calculate length adjusted wave height
actual_lah = hs_data / (T ** 0.5)

# convert from meters to feet
actual_lah = actual_lah * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects and PST timezone
time_array = [datetime.fromisoformat(str(t)).astimezone(pst_tz) for t in time_array]

# create a feature matrix for linear regression
X = np.array([t.timestamp() for t in time_array]).reshape((-1, 1))

# make predictions on the testing set
y_pred = model.predict(X)

# convert from meters to feet
predicted_lah = y_pred * 3.281

# create the plot
fig, ax = plt.subplots()
ax.plot(time_array, actual_lah, label='Actual')
ax.plot(time_array, predicted_lah, label='Predicted')

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + buoy_number)
plt.xlabel('Time (PST)')
plt.ylabel('Wave Height (ft)')
plt.grid()
plt.legend()

# set the x-axis format to show date and time in hh:mm format
date_format = '%m/%d/%Y %H:%M'
date_formatter = plt.matplotlib.dates.DateFormatter(date_format)
ax.xaxis.set_major_formatter(date_formatter)
fig.autofmt_xdate()

# display the plot
plt.show()

# close the NetCDF dataset
nc.close()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz

# set the buoy station number
#stn = '045'
stn = '264'

# set the length of the wave period for length adjustment
T = 12

# set the date range
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(hours=12)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Realtime Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + stn + 'p1_rt.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height and period variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]

# calculate length adjusted wave height
lah = hs_data / (T ** 0.5)

# convert from meters to feet
lah = lah * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects
time_array = [datetime.fromisoformat(str(t)) for t in time_array]

# resample the data to every 30 minutes
new_time_array = []
new_lah = []
for i in range(len(time_array)):
    if i == 0:
        new_time_array.append(time_array[i])
        new_lah.append(lah[i])
    else:
        diff = time_array[i] - new_time_array[-1]
        if diff.seconds >= 1800:
            new_time_array.append(time_array[i])
            new_lah.append(lah[i])

# convert the datetime objects to UTC time zone
new_time_array_utc = [t.astimezone(utc_tz) for t in new_time_array]

# convert the datetime objects to PST time zone
new_time_array_pst = [t.astimezone(pst_tz) for t in new_time_array_utc]

# adjust the time offset by 6 hours
new_time_array_pst = [t - timedelta(hours=6) for t in new_time_array_pst]

# create the plot
fig, ax = plt.subplots()
ax.plot(new_time_array_pst, new_lah)

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + stn)
plt.xlabel('Time (PST)')
plt.ylabel('Wave Height (ft)')
plt.grid()

# set the x-axis format to show date and time in hh:mm format
date_format = '%m/%d/%Y %H:%M'
date_formatter = plt.matplotlib.dates.DateFormatter(date_format)
ax.xaxis.set_major_formatter(date_formatter)
fig.autofmt_xdate()

# display the plot
plt.show()

# close the NetCDF dataset
nc.close()

http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/model/MOP_validation/BP',buoy_number,'_forecast.nc

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz

# set the buoy station number
#stn = '045'
stn = '264'

# set the length of the wave period for length adjustment
T = 12

# set the date range
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(hours=12)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Realtime Dataset URL
forecast_data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/model/MOP_validation/BP' + stn + '_forecast.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(forecast_data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height and period variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]

# calculate length adjusted wave height
lah = hs_data / (T ** 0.5)

# convert from meters to feet
lah = lah * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects
time_array = [datetime.fromisoformat(str(t)) for t in time_array]

# resample the data to every 30 minutes
new_time_array = []
new_lah = []
for i in range(len(time_array)):
    if i == 0:
        new_time_array.append(time_array[i])
        new_lah.append(lah[i])
    else:
        diff = time_array[i] - new_time_array[-1]
        if diff.seconds >= 1800:
            new_time_array.append(time_array[i])
            new_lah.append(lah[i])

# convert the datetime objects to UTC time zone
new_time_array_utc = [t.astimezone(utc_tz) for t in new_time_array]

# convert the datetime objects to PST time zone
new_time_array_pst = [t.astimezone(pst_tz) for t in new_time_array_utc]

# adjust the time offset by 6 hours
new_time_array_pst = [t - timedelta(hours=6) for t in new_time_array_pst]

# create the plot
fig, ax = plt.subplots()
ax.plot(new_time_array_pst, new_lah)

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + stn)
plt.xlabel('Time (PST)')
plt.ylabel('Wave Height (ft)')
plt.grid()

# set the x-axis format to show date and time in hh:mm format
date_format = '%m/%d/%Y %H:%M'
date_formatter = plt.matplotlib.dates.DateFormatter(date_format)
ax.xaxis.set_major_formatter(date_formatter)
fig.autofmt_xdate()

# display the plot
plt.show()

# close the NetCDF dataset
nc.close()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz

# set the buoy station number
stn = '045'

# set the date range
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(hours=12)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Realtime Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + stn + 'p1_rt.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave frequency variable
freq_var = nc.variables['waveFrequency']
freq = freq_var[:]

# get the wave spectral density variable
spec_var = nc.variables['waveSpectrum']
spec = spec_var[start_index:end_index+1, :]

# calculate the wave energy density
E = spec * freq[np.newaxis, :] * 2 * np.pi

# calculate the significant wave height
Hs = 4 * np.sqrt(np.sum(E, axis=1))

# calculate the peak wave frequency
fp = freq[np.argmax(spec, axis=1)]

# calculate the length-adjusted wave height using the Pierson-Moskowitz spectrum
T = 1 / fp
C = 0.016  # constant for Pierson-Moskowitz spectrum
lah = Hs / (T ** 0.5) * C

# convert from meters to feet
lah = lah * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects
time_array = [datetime.fromisoformat(str(t)) for t in time_array]

# resample the data to every 30 minutes
new_time_array = []
new_lah = []
for i in range(len(time_array)):
    if i == 0:
        new_time_array.append(time_array[i])
        new_lah.append(lah[i])
    else:
        diff = time_array[i] - new_time_array[-1]
        if diff.seconds >= 1800:
            new_time_array.append(time_array[i])
            new_lah.append(lah[i])

# convert the datetime objects to UTC time zone
new_time_array_utc = [t.astimezone(utc_tz) for t in new_time_array]

# convert the datetime objects to PST time zone
new_time_array_pst = [t.astimezone(pst_tz) for t in new_time_array_utc]

# adjust the time offset by 6 hours
new_time_array_pst = [t - timedelta(hours=6) for t in new_time_array_pst]

# create the plot
fig, ax = plt.subplots()
ax.plot(new_time_array_pst, new_lah)

# format the plot
plt.title

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz

# set the buoy station number
stn = '045'
#stn = '264'

# set the length of the wave period for length adjustment
T = 12

# set the date range
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(hours=12)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Historic Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + stn + 'p1_rt.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height, period, mean direction, frequency, and energy density variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']
dmean_var = nc.variables['waveMeanDirection']
fq_var = nc.variables['waveFrequency']
ed_var = nc.variables['waveEnergyDensity']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]
dmean_data = dmean_var[start_index:end_index+1]
fq_data = fq_var[:]
ed_data = ed_var[start_index:end_index+1,:]

# calculate length adjusted wave height using the Pierson-Moskowitz formula
g = 9.81  # acceleration due to gravity
fp = 1 / T  # peak frequency
spectrum = (5/16) * (hs_data**2) * (fp**4) / (g**2)
lah = np.sqrt(2 * spectrum / fp)

# convert from meters to feet
lah = lah * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects and PST timezone
time_array = [datetime.fromisoformat(str(t)).astimezone(pst_tz) for t in time_array]

# adjust the time offset by 6 hours
time_array_pst = [t - timedelta(hours=6) for t in time_array_pst]

# create the plot
fig, ax = plt.subplots()
ax.plot(time_array, lah)

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + buoy_number)
plt.xlabel('Time (PST)')
plt.ylabel('Wave Height (ft)')
plt.grid()

# set the x-axis format to show date and time in hh:mm format
date_format = '%m/%d/%Y %H:%M'
date_formatter = plt.matplotlib.dates.DateFormatter(date_format)
ax.xaxis.set_major_formatter(date_formatter)
fig.autofmt_xdate()

# display the plot
plt.show()

# close the NetCDF dataset
nc.close()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz

# set the buoy station number
stn = '045'

# set the length of the wave period for length adjustment
T = 12

# set the date range
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(hours=12)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Realtime Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + stn + 'p1_rt.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height, period, mean direction, frequency, and energy density variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']
dmean_var = nc.variables['waveMeanDirection']
fq_var = nc.variables['waveFrequency']
ed_var = nc.variables['waveEnergyDensity']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]
dmean_data = dmean_var[start_index:end_index+1]
fq_data = fq_var[:]
ed_data = ed_var[start_index:end_index+1,:]

# calculate length adjusted wave height using the JONSWAP spectrum
g = 9.81  # acceleration due to gravity
fp = 1 / T  # peak frequency
sigma = 0.07
s_pm = np.zeros_like(fq_data)
f0 = 1.0 / (2.0 * np.pi) * np.sqrt(g / fp)
alpha = 0.076 if fp <= 1. / 3 else 0.035
gamma = 3.3 if fp <= 1. / 3 else 5.0
s_pm = alpha * g**2 * fq_data**(-5) * np.exp(-1.25 * (fq_data / fp)**(-4)) * gamma**(np.exp(-(fq_data - fp)**2 / (2 * sigma**2 * fp**2)))
s_pm[fq_data > 5 * fp] = 0
spectrum = np.trapz(s_pm[:,np.newaxis] * fq_data[np.newaxis,:], fq_data, axis=1)
lah = np.sqrt(2 * spectrum)

# convert from meters to feet
lah = lah * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects and PST timezone
time_array = [datetime.fromisoformat(str(t)).astimezone(pst_tz) for t in time_array]

# resample the data to every 30 minutes
new_time_array = []
new_lah = []
for i in range(len(time_array)):
    if i == 0:
        new_time_array.append(time_array[i])
        new_lah.append(lah[i])
    else:
        diff = time_array[i] - new_time_array[-1]
        if diff.seconds >= 1800:
            new_time_array.append(time_array[i])
            new_lah.append(lah[i])

# convert the datetime objects to UTC time zone
new_time_array_utc = [t.astimezone(utc_tz) for t in new_time_array]

# convert the datetime objects to PST time zone
new_time_array_pst = [t.astimezone(pst_tz) for t in new_time_array_utc]

# adjust the time offset by 6 hours
new_time_array_pst = [t - timedelta(hours=6) for t in new_time_array_pst]

# create the plot
fig, ax = plt.subplots()
ax.plot(new_time_array_pst, new_lah)

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + stn)
plt.xlabel('Time (PST)')
plt.ylabel('Wave Height (ft)')
plt.grid()

# set the x-axis format to show date and time in hh:mm format
date_format = '%m/%d/%Y %H:%M'
date_formatter = plt.matplotlib.dates.DateFormatter(date_format)
ax.xaxis.set_major_formatter(date_formatter)
fig.autofmt_xdate()

# display the plot
plt.show()

# close the NetCDF dataset
nc.close()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz

# set the buoy station number
stn = '045'
#stn = '264'

# set the length of the wave period for length adjustment
T = 12

# set the date range
#end_time_utc = datetime.utcnow()
#start_time_utc = end_time_utc - timedelta(hours=12)
start_time_utc = datetime(2023, 2, 28)
end_time_utc = datetime(2023, 3, 6, 9)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Realtime Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + stn + 'p1_rt.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height, period, mean direction, frequency, and energy density variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']
dmean_var = nc.variables['waveMeanDirection']
fq_var = nc.variables['waveFrequency']
ed_var = nc.variables['waveEnergyDensity']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]
dmean_data = dmean_var[start_index:end_index+1]
fq_data = fq_var[:]
ed_data = ed_var[start_index:end_index+1,:]

# calculate length adjusted wave height using the Pierson-Moskowitz formula
g = 9.81  # acceleration due to gravity
fp = 1 / T  # peak frequency
spectrum = (5/16) * (hs_data**2) * (fp**4) / (g**2)
lah = np.sqrt(2 * spectrum / fp) * 200  # adjust by a factor of 200

# convert from meters to feet
lah = lah * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects and PST timezone
time_array = [datetime.fromisoformat(str(t)).astimezone(pst_tz) for t in time_array]

# adjust the time offset by 6 hours
time_array = [t - timedelta(hours=6) for t in time_array]

# create the plot
fig, ax = plt.subplots()
ax.plot(time_array, lah)

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + stn)
plt.xlabel('Time (PST)')
plt.ylabel('Wave Height (ft)')
plt.grid()

# set the x-axis format to show date and time in hh:mm format
date_format = '%m/%d/%Y %H:%M'
date_formatter = plt.matplotlib.dates.DateFormatter(date_format)
ax.xaxis.set_major_formatter(date_formatter)
fig.autofmt_xdate()

# display the plot
plt.show()

print(lah[-5:])

# close the NetCDF dataset
nc.close()

import numpy as np
import matplotlib.pyplot as plt
from netCDF4 import Dataset

# Set the station number and URL
stn = "045"
url = f'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/{stn}p1_rt.nc'

# Open the NetCDF file and read the data
with Dataset(url) as nc:
    wave_height = nc.variables['waveHs'][:]
    wave_period = nc.variables['waveTp'][:]
    water_depth = 1e6  # Using very deep (near-infinite)

# Calculate the surf similarity parameter (ξ)
xi = wave_height / (wave_period * water_depth)

# Define a function to predict breaker height based on Komar and Gaughan's model
def breaker_height(wave_height, xi):
    plunging = 0.8 * wave_height
    spilling = 0.4 * wave_height * (2 * xi)
    return np.where(xi < 0.5, plunging, spilling)

# Calculate the breaker height
breaker_heights = breaker_height(wave_height, xi)

# Plot the breaker height vs. significant wave height
plt.scatter(wave_height, breaker_heights)
plt.xlabel("Significant Wave Height (m)")
plt.ylabel("Breaker Height (m)")
plt.title("Breaker Height vs. Significant Wave Height")
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from netCDF4 import Dataset

# Conversion factors
m_to_ft = 3.28084

# Set the station number and URL
stn = "045"
url = f'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/{stn}p1_rt.nc'

# Open the NetCDF file and read the data
with Dataset(url) as nc:
    wave_height = nc.variables['waveHs'][:] * m_to_ft
    wave_period = nc.variables['waveTp'][:]
    water_depth = 1e6 * m_to_ft  # Assuming near-infinite depth

# Calculate the surf similarity parameter (ξ)
xi = wave_height / (wave_period * water_depth)

# Define a function to predict breaker height based on Komar and Gaughan's model
def breaker_height(wave_height, xi):
    plunging = 0.8 * wave_height
    spilling = 0.4 * wave_height * (2 * xi)
    return np.where(xi < 0.5, plunging, spilling)

# Calculate the breaker height
breaker_heights = breaker_height(wave_height, xi)

# Plot the breaker height vs. significant wave height
plt.scatter(wave_height, breaker_heights)
plt.xlabel("Significant Wave Height (ft)")
plt.ylabel("Breaker Height (ft)")
plt.title("Breaker Height vs. Significant Wave Height")
plt.grid()
plt.show()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz

# set the buoy station number
stn = '045'
#stn = '264'

# set the length of the wave period for length adjustment
T = 12

# set the date range
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(hours=12)
#start_time_utc = datetime(2023, 2, 28)
#end_time_utc = datetime(2023, 3, 6, 9)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Realtime Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + stn + 'p1_rt.nc'
#data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/model/MOP_validation/BP' + stn + '_forecast.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height, period, mean direction, frequency, and energy density variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']
dmean_var = nc.variables['waveMeanDirection']
fq_var = nc.variables['waveFrequency']
ed_var = nc.variables['waveEnergyDensity']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]
dmean_data = dmean_var[start_index:end_index+1]
fq_data = fq_var[:]
ed_data = ed_var[start_index:end_index+1,:]

# calculate length adjusted wave height using the Pierson-Moskowitz formula
g = 9.81  # acceleration due to gravity
fp = 1 / T  # peak frequency
spectrum = (5/16) * (hs_data**2) * (fp**4) / (g**2)
lah = np.sqrt(2 * spectrum / fp) * 200  # adjust by a factor of 200

# convert from meters to feet
lah = lah * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects and PST timezone
time_array = [datetime.fromisoformat(str(t)).astimezone(pst_tz) for t in time_array]

# adjust the time offset by 6 hours
time_array = [t - timedelta(hours=6) for t in time_array]

# create the plot
fig, ax = plt.subplots()
ax.plot(time_array, lah)

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + stn)
plt.xlabel('Time (PST)')
plt.ylabel('Wave Height (ft)')
plt.grid()

# set the x-axis format to show date and time in hh:mm format
date_format = '%m/%d/%Y %H:%M'
date_formatter = plt.matplotlib.dates.DateFormatter(date_format)
ax.xaxis.set_major_formatter(date_formatter)
fig.autofmt_xdate()

# display the plot
plt.show()

# close the NetCDF dataset
nc.close()

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz

# Set the buoy station number
stn = '045'

# Set the length of the wave period for length adjustment
T = 12

# Set the date range
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(hours=12)
#start_time_utc = datetime(2023, 2, 28)
#end_time_utc = datetime(2023, 3, 6, 9)

# Convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Realtime Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + stn + 'p1_rt.nc'

# Open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# Get the time variable
time_var = nc.variables['waveTime']

# Find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# Get the wave height and period data for the time range
hs_data = nc.variables['waveHs'][start_index:end_index+1]
t_data = nc.variables['waveTp'][start_index:end_index+1]

# Convert from meters to feet
hs_data_ft = hs_data * 3.281

# Airy wave theory breaker height prediction
def breaker_height_airy(hs, t):
    g = 9.81  # acceleration due to gravity
    L = (g * t**2) / (2 * np.pi)  # wavelength
    h_breaker = 0.78 * L * np.tanh(0.53 * (2 * np.pi * 10) / L)
    return h_breaker * 3.281

# Calculate breaker heights using Airy wave theory
breaker_heights_airy = breaker_height_airy(hs_data, t_data)

# Create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# Convert the cftime objects to datetime objects and PST timezone
time_array = [datetime.fromisoformat(str(t)).astimezone(pst_tz) for t in time_array]

# Adjust the time offset by 6 hours
time_array = [t - timedelta(hours=6) for t in time_array]

# Create the plot of significant wave height vs breaker height (Airy wave theory)
fig, ax = plt.subplots()
ax.scatter(hs_data_ft, breaker_heights_airy)

# Format the plot
plt.title('Breaker Height vs. Significant Wave Height (Airy wave theory)')
plt.xlabel('Significant Wave Height (ft)')
plt.ylabel('Breaker Height (ft)')
plt.grid()

# Display the plot
plt.show()

# Close the NetCDF dataset
nc.close()

!pip install netCDF4

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz

# set the buoy station number
stn = '045'
#stn = '264'

# set the length of the wave period for length adjustment
#T = 12

# set the date range
#end_time_utc = datetime.utcnow()
#start_time_utc = end_time_utc - timedelta(hours=12)
start_time_utc = datetime(2023, 2, 27)
end_time_utc = datetime(2023, 3, 7)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Realtime Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + stn + 'p1_rt.nc'
data_url_forecast = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/model/MOP_validation/BP' + stn + '_forecast.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# open the forecast NetCDF dataset
nc_f = netCDF4.Dataset(data_url_forecast)

# get the time variable
time_var = nc.variables['waveTime']

# get the forecast time variable
time_var_f = nc_f.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# find the forecast indices for the time range
start_index_forecast = netCDF4.date2index(start_time, time_var_f, select='nearest')
end_index_forecast = netCDF4.date2index(end_time, time_var_f, select='nearest')

# get the wave height, period, mean direction, frequency, and energy density variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']
dmean_var = nc.variables['waveMeanDirection']
fq_var = nc.variables['waveFrequency']
ed_var = nc.variables['waveEnergyDensity']

# get the forecast wave height, period, mean direction, frequency, and energy density variables
hs_var_f = nc_f.variables['waveHs']
t_var_f = nc_f.variables['waveTp']
dmean_var_f = nc_f.variables['waveMeanDirection']
fq_var_f = nc_f.variables['waveFrequency']
ed_var_f = nc_f.variables['waveEnergyDensity']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]
dmean_data = dmean_var[start_index:end_index+1]
fq_data = fq_var[:]
ed_data = ed_var[start_index:end_index+1,:]
T = np.mean(t_data)

# extract the forecast wave height and period data for the time range
hs_data_f = hs_var_f[start_index_forecast:end_index_forecast+1]
t_data_f = t_var_f[start_index_forecast:end_index_forecast+1]
dmean_data_f = dmean_var_f[start_index_forecast:end_index_forecast+1]
fq_data_f = fq_var_f[:]
ed_data_f = ed_var_f[start_index_forecast:end_index_forecast+1,:]
T_f = np.mean(t_data_f)

# calculate length adjusted wave height using the Pierson-Moskowitz formula
g = 9.81  # acceleration due to gravity
fp = 1 / T  # peak frequency
spectrum = (5/16) * (hs_data**2) * (fp**4) / (g**2)
lah = np.sqrt(2 * spectrum / fp) * 360  # adjust by a factor of 200

# calculate forecast length adjusted wave height using the Pierson-Moskowitz formula
g = 9.81  # acceleration due to gravity
fp_f = 1 / T_f  # peak frequency
spectrum_f = (5/16) * (hs_data_f**2) * (fp_f**4) / (g**2)
lah_f = np.sqrt(2 * spectrum_f / fp_f) * 360  # adjust by a factor of 20

# convert from meters to feet
lah = lah * 3.281

# convert from meters to feet (forecast)
lah_f = lah_f * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# create a forecast time array for plotting
time_array_f = netCDF4.num2date(time_var_f[start_index_forecast:end_index_forecast+1], time_var_f.units).tolist()

# convert the cftime objects to datetime objects and PST timezone
time_array = [datetime.fromisoformat(str(t)).astimezone(pst_tz) for t in time_array]

# convert the forecast cftime objects to datetime objects and PST timezone
time_array_f = [datetime.fromisoformat(str(t)).astimezone(pst_tz) for t in time_array_f]

# adjust the time offset by 6 hours
time_array = [t - timedelta(hours=6) for t in time_array]

# adjust the forecast time offset by 6 hours
time_array_f = [t - timedelta(hours=6) for t in time_array_f]

import matplotlib.pyplot as plt

# create the plot
fig, ax = plt.subplots()

# plot the data and forecast on the same axis object
ax.plot(time_array, lah, label='Length-Adjusted Wave Height')
ax.plot(time_array_f, lah_f, label='Forecasted Length-Adjusted Wave Height')

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + stn)
plt.xlabel('Time (PST)')
plt.ylabel('Wave Height (ft)')
plt.grid()

# set the x-axis format to show date and time in hh:mm format
date_format = '%m/%d/%Y %H:%M'
date_formatter = plt.matplotlib.dates.DateFormatter(date_format)
ax.xaxis.set_major_formatter(date_formatter)
fig.autofmt_xdate()

# add a legend to the plot
plt.legend()

# display the plot
plt.show()

# close the NetCDF dataset
nc.close()

"""Need to update script above to iterate through 'waveTp' when calculating fp.  

---

Tried it using the code below and it doesn't work very well.
"""

#Same as the code above but removes forecast and iterates through waveTp values rather than using the mean of all waveTp values#

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz

# set the buoy station number
stn = '045'
#stn = '264'

# set the date range
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(hours=12)
#start_time_utc = datetime(2023, 2, 28)
#end_time_utc = datetime(2023, 3, 6, 9)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Realtime Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + stn + 'p1_rt.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height, period, mean direction, frequency, and energy density variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']
dmean_var = nc.variables['waveMeanDirection']
fq_var = nc.variables['waveFrequency']
ed_var = nc.variables['waveEnergyDensity']

# extract the wave height and period data for the time range
hs_data = hs_var[start_index:end_index+1]
t_data = t_var[start_index:end_index+1]
dmean_data = dmean_var[start_index:end_index+1]
fq_data = fq_var[:]
ed_data = ed_var[start_index:end_index+1,:]

# calculate length adjusted wave height using the Pierson-Moskowitz formula
g = 9.81  # acceleration due to gravity
lah = []
for i in range(len(t_data)):
    T = t_data[i]
    fp = 1 / T  # peak frequency
    spectrum = (5/16) * (hs_data[i]**2) * (fp**4) / (g**2)
    lah.append(np.sqrt(2 * spectrum / fp) * 200) # adjust by a factor of 200

# convert from meters to feet
lah = np.array(lah) * 3.281

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects and PST timezone
time_array = [datetime.fromisoformat(str(t)).astimezone(pst_tz) for t in time_array]

# adjust the time offset by 6 hours
time_array = [t - timedelta(hours=6) for t in time_array]

import matplotlib.pyplot as plt

# create the plot
fig, ax = plt.subplots()

# plot the data on the axis object
ax.plot(time_array, lah, label='Length-Adjusted Wave Height')

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + stn)
plt.xlabel('Time (PST)')
plt.ylabel('Wave Height (ft)')
plt.grid()

# set the x-axis format to show date and time in hh:mm format
date_format = '%m/%d/%Y %H:%M'
date_formatter = plt.matplotlib.dates.DateFormatter(date_format)
ax.xaxis.set_major_formatter(date_formatter)
fig.autofmt_xdate()

# add a legend to the plot
plt.legend()

# display the plot
plt.show()

# close the NetCDF dataset
nc.close()

!pip install netCDF4

#Uses the Carderock method of using centroids to approximate the PM LA SWH#

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz

g = 9.81  # gravitational acceleration in m/s^2

# set the buoy station number
stn = '045'
#stn = '264'

# set the date range
end_time_utc = datetime.utcnow()
start_time_utc = end_time_utc - timedelta(hours=12)
#start_time_utc = datetime(2023, 2, 28)
#end_time_utc = datetime(2023, 3, 6, 9)

# convert UTC time to PST time
utc_tz = pytz.timezone('UTC')
pst_tz = pytz.timezone('US/Pacific')
end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

# CDIP Realtime Dataset URL
data_url = 'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/' + stn + 'p1_rt.nc'

# open the NetCDF dataset
nc = netCDF4.Dataset(data_url)

# get the time variable
time_var = nc.variables['waveTime']

# find the indices for the time range
start_index = netCDF4.date2index(start_time, time_var, select='nearest')
end_index = netCDF4.date2index(end_time, time_var, select='nearest')

# get the wave height, period, mean direction, frequency, and energy density variables
hs_var = nc.variables['waveHs']
t_var = nc.variables['waveTp']
fq_var = nc.variables['waveFrequency']
ed_var = nc.variables['waveEnergyDensity']
tz_var = nc.variables['waveTz']

# extract the wave height and period data for the time range
waveHs = hs_var[start_index:end_index+1]
waveTp = t_var[start_index:end_index+1]
waveFrequency = fq_var[:]
waveEnergyDensity = ed_var[start_index:end_index+1,:]
waveTz = tz_var[start_index:end_index+1]

# Convert waveHs and waveTp to numpy arrays
waveHs = np.array(waveHs)
waveTp = np.array(waveTp)

# Convert waveEnergyDensity to a numpy array
waveEnergyDensity = np.array(waveEnergyDensity)

# Initialize an empty list to store the Hsea and HsPM values for each time step
Hsea_list = []
HsPM_list = []
Cmeas_list = []
CPM_list = []

# Iterate through the time range
for i in range(end_index - start_index + 1):
    # Extract the wave height, period, and energy density for the current time step
    waveHs_i = waveHs[i]
    waveTp_i = waveTp[i]
    waveEnergyDensity_i = waveEnergyDensity[i, :]
    waveTz_i = waveTz[i]

    # Calculate the centroid of the measured wave spectrum for the current time step
    Cmeas = np.sum(waveFrequency * waveEnergyDensity_i) / np.sum(waveEnergyDensity_i)

    Cmeas_list.append(Cmeas)

    # Calculate HsPM, lambda, Tz, fp, and CPM for the current time step
    #HsPM = 0.21 * g**2 * waveTp_i**2 / (2 * np.pi)
    HsPM = 0.21 * (g * waveTp_i / (2 * np.pi)) ** (1/2)
    HsPM_list.append(HsPM)
    #lambda_ = g * waveTp_i**2 / (2 * np.pi)
    #Tz = waveTp_i / (1. + 0.666 * (HsPM/lambda_)**0.5)
    #fp = 1.0 / (1.56 * waveTz_i)
    fp = 1.0 / waveTz_i
    CPM = 3.11 * HsPM / fp
    CPM_list.append(CPM)

    # Calculate the effective significant wave height for the current time step
    Hsea = waveHs_i * Cmeas / CPM
    Hsea_list.append(Hsea)

# Convert the Hsea and HsPM list to a numpy array
Hsea = np.array(Hsea_list)
HsPM_array = np.array(HsPM_list)
Cmeas = np.array(Cmeas_list)
CPM = np.array(CPM_list)

# Convert values to feet
feet_per_meter = 3.28084
waveHs_feet = waveHs * feet_per_meter
Cmeas_feet = Cmeas * feet_per_meter
CPM_feet = CPM * feet_per_meter
Hsea_feet = Hsea * feet_per_meter
HsPM_feet = HsPM_array * feet_per_meter

print("Measured significant wave height:", waveHs_feet, "ft")
print("Pierson-Moskowitz significant wave height:", HsPM_feet, "ft")
print("Centroid of the measured wave spectrum:", Cmeas_feet, "ft")
print("Centroid of Pierson-Moskowitz spectrum:", CPM_feet, "ft")
print("Effective significant wave height:", Hsea_feet, "ft")

# create a time array for plotting
time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

# convert the cftime objects to datetime objects and PST timezone
time_array = [datetime.fromisoformat(str(t)).astimezone(pst_tz) for t in time_array]

# adjust the time offset by 6 hours
time_array = [t - timedelta(hours=6) for t in time_array]

import matplotlib.pyplot as plt

# create the plot
fig, ax = plt.subplots()

# plot the data on the axis object
ax.plot(time_array, Hsea_feet, label='Length-Adjusted Wave Height')

# format the plot
plt.title('Length-Adjusted Wave Height for Buoy ' + stn)
plt.xlabel('Time (PST)')
plt.ylabel('Wave Height (ft)')
plt.grid()

# set the x-axis format to show date and time in hh:mm format
date_format = '%m/%d/%Y %H:%M'
date_formatter = plt.matplotlib.dates.DateFormatter(date_format)
ax.xaxis.set_major_formatter(date_formatter)
fig.autofmt_xdate()

# add a legend to the plot
plt.legend()

# display the plot
plt.show()

# close the NetCDF dataset
nc.close()

!pip install netCDF4

import netCDF4
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pytz

# Download wave data from CDIP for specified time period and station ID
def download_wave_data(stn, start_time, end_time):
    data_url = f'http://thredds.cdip.ucsd.edu/thredds/dodsC/cdip/realtime/{stn}p1_rt.nc'
    nc = netCDF4.Dataset(data_url)
    time_var = nc.variables['waveTime']
    
    # Find the nearest start and end index in the netCDF file based on the start_time and end_time provided
    start_index = netCDF4.date2index(start_time, time_var, select='nearest')
    end_index = netCDF4.date2index(end_time, time_var, select='nearest')
    
    # Extract necessary variables from netCDF file
    waveHs = nc.variables['waveHs'][start_index:end_index+1]
    waveTp = nc.variables['waveTp'][start_index:end_index+1]
    waveFrequency = nc.variables['waveFrequency'][:]
    waveEnergyDensity = nc.variables['waveEnergyDensity'][start_index:end_index+1,:]
    waveTz = nc.variables['waveTz'][start_index:end_index+1]

    # Convert time_var to a list of datetime objects in Pacific Standard Time (PST) and adjust for UTC offset
    time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist()

    nc.close()

    return waveHs, waveTp, waveFrequency, waveEnergyDensity, waveTz, time_array

# Calculate the effective significant wave height for each time step
def calculate_effective_wave_height(waveHs, waveTp, waveFrequency, waveEnergyDensity, waveTz):
    g = 9.81
    Hsea_list = []
    HsPM_list = []
    Cmeas_list = []
    CPM_list = []
    
    # Loop through each time step in the input data and calculate Hsea, HsPM, Cmeas, and CPM for that time step
    for i in range(len(waveHs)):
        waveHs_i = waveHs[i]
        waveTp_i = waveTp[i]
        waveEnergyDensity_i = waveEnergyDensity[i, :]
        waveTz_i = waveTz[i]

        # Calculate the centroid frequency of the measured spectrum (Cmeas)
        Cmeas = np.sum(waveFrequency * waveEnergyDensity_i) / np.sum(waveEnergyDensity_i)
        Cmeas_list.append(Cmeas)

        # Calculate the Pierson-Moskowitz significant wave height (HsPM) and use it to calculate B and fp for the PM spectrum
        HsPM = 0.21 * (g * waveTp_i / (2 * np.pi)) ** (1/2)
        HsPM_list.append(HsPM)
        B = (5/4) * (HsPM ** 2) / (g ** 2) #Testing to see if it works
        fp = 1.0 / (1.56 * waveTz_i)

        # Calculate the centroid frequency of the Pierson-Moskowitz spectrum (CPM)
        CPM = g / (2 * np.pi) * np.sqrt(B / fp) #Testing to see if it works
        #CPM = 3.11 * HsPM / fp
        CPM_list.append(CPM)
        
        # Calculate the effective significant wave height for the current time step
        Hsea = waveHs_i * Cmeas / CPM
        Hsea_list.append(Hsea)

    return np.array(Hsea_list), np.array(HsPM_list), np.array(Cmeas_list), np.array(CPM_list)

def plot_wave_height(time_array, Hsea_feet, stn):

    # Create a new figure and axes objects
    fig, ax = plt.subplots()

    # Plot the Hsea_feet values against the corresponding time_array values
    ax.plot(time_array, Hsea_feet, label='Length-Adjusted Wave Height')

    # Set the title and axis labels for the plot
    plt.title(f'Length-Adjusted Wave Height for Buoy {stn}')
    plt.xlabel('Time (PST)')
    plt.ylabel('Wave Height (ft)')

    # Add a grid to the plot
    plt.grid()

    # Set the date format for the x-axis labels
    date_format = '%m/%d/%Y %H:%M'
    date_formatter = plt.matplotlib.dates.DateFormatter(date_format)
    ax.xaxis.set_major_formatter(date_formatter)

    # Rotate the x-axis labels for better readability
    fig.autofmt_xdate()

    # Add a legend to the plot and display it
    plt.legend()
    plt.show()

#Main function
def main():

    # Set the buoy station ID and time range for data download
    stn = '045'
    end_time_utc = datetime.utcnow()
    start_time_utc = end_time_utc - timedelta(hours=12)

    # Set the timezones for the start and end times
    utc_tz = pytz.timezone('UTC')
    pst_tz = pytz.timezone('US/Pacific')

    # Convert the start and end times to the Pacific timezone
    end_time = utc_tz.localize(end_time_utc).astimezone(pst_tz)
    start_time = utc_tz.localize(start_time_utc).astimezone(pst_tz)

    # Download the wave data for the specified time range
    waveHs, waveTp, waveFrequency, waveEnergyDensity, waveTz, time_array = download_wave_data(stn, start_time, end_time)

    # Calculate the effective wave height and Pierson-Moskowitz significant wave height
    Hsea, HsPM, Cmeas, CPM = calculate_effective_wave_height(waveHs, waveTp, waveFrequency, waveEnergyDensity, waveTz)

    # Convert the wave height units from meters to feet
    feet_per_meter = 3.28084
    waveHs_feet = waveHs * feet_per_meter
    Cmeas_feet = Cmeas * feet_per_meter
    CPM_feet = CPM * feet_per_meter
    Hsea_feet = Hsea * feet_per_meter
    HsPM_feet = HsPM * feet_per_meter

    # Print out the measured, Pierson-Moskowitz, and effective wave heights
    print(f"Measured significant wave height: {waveHs_feet} ft")
    print(f"Pierson-Moskowitz significant wave height: {HsPM_feet} ft")
    print(f"Centroid of the measured wave spectrum: {Cmeas_feet} ft")
    print(f"Centroid of Pierson-Moskowitz spectrum: {CPM_feet} ft")
    print(f"Effective significant wave height: {Hsea_feet} ft")

    #time_array = netCDF4.num2date(time_var[start_index:end_index+1], time_var.units).tolist() #not needed when called and stored in def download
    time_array = [datetime.fromisoformat(str(t)).astimezone(pst_tz) for t in time_array]
    time_array = [t - timedelta(hours=6) for t in time_array]

    plot_wave_height(time_array, Hsea_feet, stn)

if __name__ == "__main__":
    main()